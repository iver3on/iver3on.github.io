---
layout: post
title:  "数据结构中一些杂碎概念"
date:   2016-05-09 09:14:54
categories: ds
tags: ds tree algorithm node
---

* content
{:toc}

总结一些数据结构中常见的疑难概念，基础但是不失核心。





### 主要难点概念

1、线性表可以是空表，树可以是空树，但是图不可以是空图。图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。

2、哈弗曼树是：在含有带权叶子节结点的二叉树中，其中带权路径长度WPL最小的二叉树称为哈弗曼树，也称为最优二叉树。

3、从跟结点到任意结点的路径长度（经过的边树）与该结点上权值的乘积称为该结点的带权路径长度。

4、完全图：在无向图中，如果任意两个顶点之间都存在边，则称改图为无向完全图。有向图中任意两个结点之间都存在方向相反的两条弧，则为有向完全图。

5、在无向图中，如从顶点v到顶点w有路径存在，则称v和w是连通的。

6、强连通图：在有向图中，若从顶点v到顶点W和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图是强连通图。强连通图、强连通分量只是针对有向图而言。无向图中讨论连通性。

7、在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路。回路对应路径。简单回路对应简单路径。

8、图的存储方式主要两种：邻接矩阵和邻接表。前者属于图的顺序存储结构，后者是链接存储。

9、邻接矩阵存储就是用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各个顶点之间的邻接关系），这个二维数组就称为邻接矩阵。稠密图适合用邻接矩阵的存储表示。

邻接矩阵 (2)

10、确定图中的边数时候，使用邻接矩阵有局限性。花费时间代价太大。

11、稀疏图适合使用邻接表法进行存储。减少了不必要的空间浪费。但是如果要确定给定的两个顶点间是否存在边，则在邻接矩阵里立刻可以查到，在邻接表中需要在相应结点对应的边表中查找另一个结点，效率较低。

邻接表

12、图的遍历主要两种算法：广度优先搜索和深度优先搜索。

13、广度优先搜索Breadth-First-Search BFS的思想:类似于二叉树的层序遍历算法。首先访问起始顶点v,接着由v出发，依次访问v的各个未被访问过的临接顶点w1,w2……wi，然后再依次访问顶点w1,w2……wi的所有未被访问过的临接顶点；再从这些访问过的顶点出发，再访问他们所有未被访问过的临接顶点….以此类推，直到图中所有顶点都被访问过为止。类似的思想还有Dijkstra单源最短路径算法和Prim最小生成树算法。算法需要一个辅助队列，以记忆正在访问的顶点的下一层顶点。广度优先搜索是一种分层的遍历过程，每向前走一步可能访问一批顶点，不像DFS一样有回退的情况，因此，BFS不是一种递归的过程。

14、深度优先搜索Depth-First-Search DFS类似于树的先序遍历。首先访问图中的某一起始顶点v，由v出发，访问与v邻接且未被访问过的任一项顶点w1,再访问与w1邻接且未被访问的任一顶点w2…..重复上述过程。当不能再继续向下访问的时候，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从改顶点开始继续上述搜索过程，直到图中所有顶点被访问过为止。DFS利用回溯法对图遍历，一般利用递归方式实现，每当向前递归查找某一邻接结点之前，必须判断该结点是否访问过。另外，递归算法均可以借助栈来实现非递归算法，深度优先搜索也不例外。

15、对于同样一个图，基于邻接矩阵的遍历得到的DFS和BFS序列是唯一的，基于邻接表的遍历得到的DFS和BFS序列是不唯一的。

16、最小生成树Minimum-Spanning-Tree MST包含图的所有顶点，并且只含尽可能少的边。

17、Prim算法是从顶点开始扩展最小生成树，算法时间复杂度是O(|V^2|),适合于求解边稠密的图。Kruskal算法是一种按照权值的递增次序选择合适的边构造最小生成树，算法时间复杂度是O(|E|log|E|)，适合于边稀疏而顶点较多的图。

18、带权有向图G的最短路径问题一般分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过Dijkstra算法求解；二是求每一对顶点之间的最短路径，可以通过Floyd-Warshall算法求解。

19、Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。

20、Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。动态规划的思想。

两个算法详细解释：Dijkstra&floyd

21：拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时候，称为该图的一个拓扑排序。

a.每个顶点出现且出现一次。

b.若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。

拓扑排序的事件复杂度是O(|v|+|E|).

2012计算机联考题：

若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为0，则该图的拓扑序列：

A。存在，且唯一B。存在，且不唯一C。存在，可能不唯一D。无法去确定是否存在

选择C。对角线以下元素均为0，表明只有顶点i到顶点j（i<j）可能有边，而顶点j到顶点i一定没有边，即有向图是一个无环图，因此一定存在拓扑序列。

22、查找：

a。顺序查找

b。折半查找 时间复杂度是O（log2n）

c。分块查找。又称索引顺序查找，吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。

23、散列（Hash）表

散列函数：一个吧查找表中的关键字映射成改关键字对应的地址的函数，记为Hash(key)=Addr。这里的地址可以是数组下标、索引、或内存地址等。

冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”。这些发生碰撞的不同关键字称为同义词。

散列表：是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。

理想情况下对散列表查找的时间复杂度是O(1)。

几种散列函数：

直接定址法  直接取关键字的某个线性函数值为散列地址。最简单且不会产生冲突。适合关键字的分布基本连续的情况。
除留余数法   H（key） = key%p,p取不大于m散列表长度但最接近于或等于m的质数p。
数字分析法  适合于已知的关键字集合。
平方取中法  取关键字的平方值的中间几位作为散列地址。适合于关键字的每一位取值都不均匀或均小于散列地址所需的位数。
折叠法   关键字位数很多，而且关键字中每一位上数字分布大致均匀时候，采用折叠法。
处理冲突的方法：

开放地址法
         a.线性探测法  b平方探测法 c再散列法  需要两个散列函数 d 伪随机序列法

拉链法

24、排序

插入排序：1直接插入排序2 二分插入排序 3 希尔排序

交换排序:   1 冒泡排序 2快速排序

选择排序：1 简单选择排序 2堆排序

归类	    名称	      最好时间效率	最坏时间效率	平均时间效率	空间效率	稳定性	
插入排序	直接插入排序	O(n)	    O(n^2)	            O(n^2)	      O(1)	    稳定	
插入排序	折半插入排序	O(n)	    O(n^2)		        O(1)	                稳定	
插入排序	希尔排序	    O(n^1.3)	O(n^2)		        O(1)	                不稳定	
交换排序	冒泡排序	    O(n^2)	    O(n^2)	            O(n^2)        O(1)	    稳定	
交换排序	快速排序	    O(nlog2n) 	O(n^2)	            O(nlog2n)	  O(log2n)	不稳定	
选择排序	简单选择排序	O(n^2)		O(n^2)	            O(n^2)	      O(1)	    不稳定	
选择排序	堆排序	        O(nlog2n)	O(nlog2n)		    O(1)	                不稳定	
归并排序	O(nlog2n)	    O(nlog2n)	O(nlog2n)	        O(n)	                稳定	
基数排序	O(d(n+r))	    O(r)	                                                稳定	不是基于比较的排序
如何选取：

* 1、直接插入排序、冒泡排序和简单选择排序是基本的排序算法，它们主要用于元素个数n不是很大,n<10000的情形。

* 2、对于中等规模的元素序列n<=1000，希尔排序是一种很好的选择。

* 3、对于元素个数n很大的情况，可以采用快排、堆排序、归并排序或者基数排序，其中快排和堆排序都是不稳定的，而归并和基数排序是稳定的。

* 4、算法混合使用
